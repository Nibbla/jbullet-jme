#summary Multithreading in jbullet-jme

== Introduction ==
jbullet-jme has been developed in a way that makes it easy to integrate it into multithreaded applications.

==Updating sequence==
  * *update(float time)*
   * queue input gets applied
   * physics update run / jme spatial update 
   * collision events get dispatched

TODO: extend
== Queues ==
jbullet-jme uses the GameTaskQueueManager of jme to allow queueing of phyiscs tasks.
{{{
//get the queue
GameTaskQueue pQueue=GameTaskQueueManager.getManager().getQueue("jbullet_update");

//create a task
Callable task=new Callable(){
    public Object call() throws Exception {
        doWork();
        return null;
    }
};

//add task
pQueue.enqueue(task);
}}}

For continuous tasks, you can requeue your task like this when it is called and wants to be called again next tick:
{{{
//requeue task
PhysicsSpace.getPhysicsSpace().requeue(task);
}}}